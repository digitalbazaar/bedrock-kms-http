/*!
 * Copyright (c) 2019-2021 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

const bedrock = require('bedrock');
const brZCapStorage = require('bedrock-zcap-storage');
const {
  defaultDocumentLoader,
  keystores,
  keyDescriptionStorage
} = require('bedrock-kms');
const forwarded = require('forwarded');
const jsigs = require('jsonld-signatures');
const {
  extendContextLoader,
  SECURITY_CONTEXT_V2_URL,
  suites: {Ed25519Signature2018}
} = jsigs;
const {config, util: {BedrockError}} = bedrock;
const {verifyCapabilityInvocation} = require('http-signature-zcap-verify');
const {CapabilityDelegation} = require('ocapld');
const {Netmask} = require('netmask');

// TODO: a lot of helper code here is in common w/ bedrock-data-hub-storage,
// consider refactoring to share it

exports.authorize = async ({
  req, expectedTarget, expectedRootCapability, expectedAction
}) => {
  const host = req.get('host');
  const url = `https://${host}${req.originalUrl}`;
  const {method, headers} = req;

  const result = await verifyCapabilityInvocation({
    url, method, headers,
    getInvokedCapability: exports.createGetInvokedCapability({host}),
    documentLoader: exports.createCapabilityLoader({host, expectedTarget}),
    expectedHost: config.server.host,
    expectedTarget, expectedRootCapability, expectedAction,
    inspectCapabilityChain: exports.inspectCapabilityChain,
    // TODO: support RsaSignature2018 and other suites?
    suite: [new Ed25519Signature2018()]
  });
  if(!result.verified) {
    throw new BedrockError(
      'Permission denied.', 'NotAllowedError', {
        httpStatusCode: 400,
        public: true
      }, result.error);
  }
  return {
    valid: result.verified,
    ...result
  };
};

// wrap document loader to always generate root zcap from keystore config
// description in storage
exports.createCapabilityLoader = ({host}) => {
  return async function rootCapabilityLoader(url) {
    const result = exports.getInvocationTarget({host, url});
    if(result) {
      // dynamically generate zcap for root capability
      const {target, keystoreId} = result;
      return {
        contextUrl: null,
        documentUrl: url,
        document: await exports.generateRootCapability(
          {id: url, target, keystoreId})
      };
    }

    return defaultDocumentLoader(url);
  };
};

exports.createGetInvokedCapability = ({host}) => {
  return async function getInvokedCapability({id, expectedTarget}) {
    try {
      // if `id` matches `expectedTarget`, assume zcap is a key
      if(id === expectedTarget) {
        // dynamically generate zcap for root capability
        const {key} = await keyDescriptionStorage.get({id});
        return key;
      }

      // if the capability is a root zcap generated by this server then its
      // `id` will map to an invocation target; if so, dynamically generate the
      // zcap as it is the root authority which is automatically authorized
      const result = exports.getInvocationTarget({host, url: id});
      if(result) {
        // dynamically generate zcap for root capability
        const {target, keystoreId} = result;
        return exports.generateRootCapability({id, target, keystoreId});
      }

      // otherwise, must get capability from authorizations storage
      const {authorization} = await brZCapStorage.authorizations.get({
        id,
        invocationTarget: expectedTarget
      });
      return authorization.capability;
    } catch(e) {
      if(e.name === 'NotFoundError') {
        throw new BedrockError(
          'Permission denied.', 'NotAllowedError', {
            httpStatusCode: 400,
            public: true
          }, e);
      }
      throw e;
    }
  };
};

exports.generateRootCapability = async ({
  id, target, keystoreId, config = null
}) => {
  if(!config) {
    ({config} = await keystores.get({id: keystoreId}));
  }
  // dynamically generate zcap for root capability
  return {
    '@context': SECURITY_CONTEXT_V2_URL,
    id,
    invocationTarget: target,
    controller: config.controller,
    invoker: config.invoker,
    delegator: config.delegator
  };
};

exports.getInvocationTarget = ({url}) => {
  // look for `/kms/keystores/<keystoreId>/zcaps/`
  const cfg = config['kms-http'];

  // FIXME: is the an acceptable way to account for the unknown namespace
  // prefix? Cannot pass namespaceId in directly here because the request
  // passes through documentLoader and webkms-switch
  const matchToken = `${cfg.routes.basePath}/keystores/`;
  let idx = url.indexOf(matchToken);
  if(idx === -1) {
    return null;
  }
  const baseKeystoreUrl = url.substr(0, idx + matchToken.length);

  // skip keystore ID
  const keystoreIdIdx = baseKeystoreUrl.length;
  idx = url.indexOf('/', keystoreIdIdx);
  if(idx === -1) {
    return null;
  }
  const keystoreId = `${baseKeystoreUrl}${url.substring(keystoreIdIdx, idx)}`;

  // skip `zcaps`
  idx = url.indexOf('zcaps/', idx + 1);
  if(idx === -1) {
    return null;
  }

  // valid root zcap invocation targets:
  // `/kms/keystores/<keystoreId>/keys`
  // `/kms/keystores/<keystoreId>/authorizations`
  // `/kms/keystores/<keystoreId>/revocations`
  const path = url.substr(idx + 6 /* 'zcaps/'.length */);
  if(!['keys', 'authorizations', 'revocations'].includes(path)) {
    return null;
  }

  // return invocation target for the given root zcap URL
  return {
    target: `${keystoreId}/${path}`,
    keystoreId
  };
};

exports.getKeystoreId = ({req, localId, routes}) => {
  return `${req.namespace.id}${routes.basePath}${routes.keystores}/${localId}`;
};

exports.inspectCapabilityChain = async ({
  capabilityChain, capabilityChainMeta
}) => {
  // collect the capability IDs and delegators for the capabilities in the chain
  const capabilities = [];
  for(const [i, capability] of capabilityChain.entries()) {
    const [{purposeResult}] = capabilityChainMeta[i].verifyResult.results;
    if(purposeResult && purposeResult.delegator) {
      capabilities.push({
        capabilityId: capability.id,
        delegator: purposeResult.delegator.id,
      });
    }
  }
  const revoked = await brZCapStorage.revocations.isRevoked({capabilities});

  if(revoked) {
    return {
      valid: false,
      error: new Error(
        'One or more capabilities in the chain have been revoked.')
    };
  }

  return {valid: true};
};

exports.verifyDelegation = async ({keystoreId, host, capability}) => {
  const invocationTarget = typeof capability.invocationTarget === 'string' ?
    capability.invocationTarget : capability.invocationTarget.id;

  const expectedRootCapability = _getExpectedRootCapability(
    {invocationTarget, keystoreId});
  const {verified, error, results} = await jsigs.verify(capability, {
    suite: new Ed25519Signature2018(),
    purpose: new CapabilityDelegation({
      expectedRootCapability,
      inspectCapabilityChain: exports.inspectCapabilityChain,
      suite: new Ed25519Signature2018()
    }),
    documentLoader: _createDocumentLoader({host, keystoreId}),
    compactProof: false
  });
  if(!verified) {
    throw error;
  }
  return results;
};

exports.verifyRequestIp = ({keystoreConfig, req}) => {
  const {ipAllowList} = keystoreConfig;
  if(!ipAllowList) {
    return {verified: true};
  }

  // the first IP in the sourceAddresses array will *always* be the IP
  // reported by Express.js via `req.connection.remoteAddress`. Any additional
  // IPs will be from the `x-forwarded-for` header.
  const sourceAddresses = forwarded(req);

  // ipAllowList is an array of CIDRs
  for(const cidr of ipAllowList) {
    const netmask = new Netmask(cidr);
    for(const address of sourceAddresses) {
      if(netmask.contains(address)) {
        return {verified: true};
      }
    }
  }

  return {verified: false};
};

/**
 * Gets an `expectedRootCapability` from an `invocationTarget`. This function
 * handles special cases where the `invocationTarget` does not match the
 * `expectedRootCapability` because the `invocationTarget` cannot be expressed
 * as a zcap.
 *
 * @param {object} options - Options to use.
 * @param {string} options.invocationTarget - An invocationTarget.
 * @param {string} options.keystoreId - A url to a key store.
 *
 * @return {string} The `expectedRootCapability` for the `invocationTarget`.
 */
function _getExpectedRootCapability({invocationTarget, keystoreId}) {
  // `authorizations` endpoint cannot be expressed as a zcap, map to zcap space
  if(invocationTarget === `${keystoreId}/authorizations`) {
    return `${keystoreId}/zcaps/authorizations`;
  }
  if(invocationTarget === `${keystoreId}/revocations`) {
    return `${keystoreId}/zcaps/revocations`;
  }
  // `keys` endpoint cannot be expressed as a zcap, map to zcap space
  if(invocationTarget === `${keystoreId}/keys`) {
    return `${keystoreId}/zcaps/keys`;
  }
  // otherwise use default behavior of `invocationTarget` matches root zcap
  return invocationTarget;
}

function _createDocumentLoader({host, keystoreId}) {
  return extendContextLoader(async url => {
    // if `id` starts with `<keystoreId>/keys/`, assume zcap is a key
    if(url.startsWith(`${keystoreId}/keys/`)) {
      // dynamically generate zcap for root capability
      const {key} = await keyDescriptionStorage.get({id: url});
      return {
        contextUrl: null,
        documentUrl: url,
        document: key
      };
    }

    // check if URL is a root zcap w/ a different invocation target
    const result = exports.getInvocationTarget({host, url});
    if(result) {
      // dynamically generate zcap for root capability
      const {target, keystoreId} = result;
      return {
        contextUrl: null,
        documentUrl: url,
        document: await exports.generateRootCapability(
          {id: url, target, keystoreId})
      };
    }

    return defaultDocumentLoader(url);
  });
}
