/*!
 * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.
 */
'use strict';

const bedrock = require('bedrock');
const brZCapStorage = require('bedrock-zcap-storage');
const {
  defaultDocumentLoader,
  // runOperation,
  // validateOperation,
  keystores,
  keyDescriptionStorage
} = require('bedrock-kms');
const jsigs = require('jsonld-signatures');
const {
  extendContextLoader,
  SECURITY_CONTEXT_V2_URL,
  suites: {Ed25519Signature2018}
} = jsigs;
const {config, util: {BedrockError}} = bedrock;
const {verifyCapabilityInvocation} = require('http-signature-zcap-verify');
const {CapabilityDelegation} = require('ocapld');

exports.authorize = async ({
  req, expectedTarget, expectedRootCapability, expectedAction
}) => {
  const host = req.get('host');
  const url = `https://${host}${req.originalUrl}`;
  const {method, headers} = req;
  const result = await verifyCapabilityInvocation({
    url, method, headers,
    getInvokedCapability: exports.createGetInvokedCapability(host),
    documentLoader: exports.createCapabilityLoader({host, expectedTarget}),
    expectedHost: config.server.host,
    expectedTarget, expectedRootCapability, expectedAction,
    // TODO: support RsaSignature2018 and other suites?
    suite: [new Ed25519Signature2018()]
  });
  if(!result.verified) {
    throw new BedrockError(
      'Permission denied.', 'NotAllowedError', {
        httpStatusCode: 400,
        public: true
      }, result.error);
  }
  return {
    valid: result.verified,
    ...result
  };
};

// wrap document loader to always generate root zcap from keystore config
// description in storage
exports.createCapabilityLoader = ({host, expectedTarget}) => {
  return async function rootCapabilityLoader(url) {
    const result = exports.getInvocationTarget({host, url});
    if(result) {
      // dynamically generate zcap for root capability
      const {target, keystoreId} = result;
      return {
        contextUrl: null,
        documentUrl: url,
        document: await exports.generateRootCapability(
          {id: url, target, keystoreId})
      };
    }

    // see if zcap is in storage
    try {
      const {authorization} = await brZCapStorage.authorizations.get(
        {id: url, invocationTarget: expectedTarget});
      return {
        contextUrl: null,
        documentUrl: url,
        document: authorization.capability
      };
    } catch(e) {
      if(e.name !== 'NotFoundError') {
        throw e;
      }
    }

    return defaultDocumentLoader(url);
  };
};

exports.createGetInvokedCapability = ({host}) => {
  return async function getInvokedCapability({id, expectedTarget}) {
    try {
      // if `id` matches `expectedTarget`, assume zcap is a key
      if(id === expectedTarget) {
        // dynamically generate zcap for root capability
        const {key} = await keyDescriptionStorage.get({id});
        return key;
      }

      // if the capability is a root zcap generated by this server then its
      // `id` will map to an invocation target; if so, dynamically generate the
      // zcap as it is the root authority which is automatically authorized
      const result = exports.getInvocationTarget({host, url: id});
      if(result) {
        // dynamically generate zcap for root capability
        const {target, keystoreId} = result;
        return exports.generateRootCapability({id, target, keystoreId});
      }

      // otherwise, must get capability from authorizations storage
      const {authorization} = await brZCapStorage.authorizations.get({
        id,
        invocationTarget: expectedTarget
      });
      return authorization.capability;
    } catch(e) {
      if(e.name === 'NotFoundError') {
        throw new BedrockError(
          'Permission denied.', 'NotAllowedError', {
            httpStatusCode: 400,
            public: true
          }, e);
      }
      throw e;
    }
  };
};

exports.generateRootCapability = async ({
  id, target, keystoreId, config = null
}) => {
  if(!config) {
    ({config} = await keystores.get({id: keystoreId}));
  }
  // dynamically generate zcap for root capability
  return {
    '@context': SECURITY_CONTEXT_V2_URL,
    id,
    invocationTarget: target,
    controller: config.controller,
    invoker: config.invoker,
    delegator: config.delegator
  };
};

exports.getInvocationTarget = ({host, url}) => {
  // look for `/kms/keystores/<keystoreId>/zcaps/`
  const cfg = config['kms-http'];
  const baseKeystoreUrl = `https://${host}${cfg.routes.basePath}/keystores/`;
  let idx = url.indexOf(baseKeystoreUrl);
  if(idx !== 0) {
    return null;
  }

  // skip keystore ID
  const keystoreIdIdx = baseKeystoreUrl.length;
  idx = url.indexOf('/', keystoreIdIdx);
  if(idx === -1) {
    return null;
  }
  const keystoreId = `${baseKeystoreUrl}${url.substring(keystoreIdIdx, idx)}`;

  // skip `zcaps`
  idx = url.indexOf('zcaps/', idx + 1);
  if(idx === -1) {
    return null;
  }

  // valid root zcap invocation targets:
  // `/kms/keystores/<keystoreId>/keys`
  // `/kms/keystores/<keystoreId>/authorizations`
  const path = url.substr(idx + 6 /* 'zcaps/'.length */);
  if(!['keys', 'authorizations'].includes(path)) {
    return null;
  }

  // return invocation target for the given root zcap URL
  return {
    target: `${keystoreId}/${path}`,
    keystoreId
  };
};

exports.getKeystoreId = ({host, req, localId, routes}) => {
  if(!host) {
    host = req.get('host');
  }
  return `https://${host}${routes.keystores}/${localId}`;
};

exports.verifyDelegation = async ({keystoreId, host, capability}) => {
  const invocationTarget = typeof capability.invocationTarget === 'string' ?
    capability.invocationTarget : capability.invocationTarget.id;
  const documentLoader = extendContextLoader(async url => {
    // if `id` starts with `<keystoreId>/keys/`, assume zcap is a key
    if(url.startsWith(`${keystoreId}/keys/`)) {
      // dynamically generate zcap for root capability
      const {key} = await keyDescriptionStorage.get({id: url});
      return {
        contextUrl: null,
        documentUrl: url,
        document: key
      };
    }

    // check if URL is a root zcap w/ a different invocation target
    const result = exports.getInvocationTarget({host, url});
    if(result) {
      // dynamically generate zcap for root capability
      const {target, keystoreId} = result;
      return {
        contextUrl: null,
        documentUrl: url,
        document: await exports.generateRootCapability(
          {id: url, target, keystoreId})
      };
    }

    // see if zcap is in storage
    try {
      const {authorization} = await brZCapStorage.authorizations.get(
        {id: url, invocationTarget});
      return {
        contextUrl: null,
        documentUrl: url,
        document: authorization.capability
      };
    } catch(e) {
      if(e.name !== 'NotFoundError') {
        throw e;
      }
    }

    return defaultDocumentLoader(url);
  });

  const {verified, error} = await jsigs.verify(capability, {
    suite: new Ed25519Signature2018(),
    purpose: new CapabilityDelegation({
      suite: new Ed25519Signature2018()
    }),
    documentLoader,
    compactProof: false
  });
  if(!verified) {
    throw error;
  }
};
